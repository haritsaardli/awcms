---
import Layout from '../layouts/Layout.astro';
import AWT01Layout from '../templates/awtemplate01/Layout.astro';
import { createScopedClient } from '../lib/supabase';
import { PuckRenderer } from '../components/PuckRenderer';
import { TipTapRenderer } from '../components/TipTapRenderer';

/**
 * Root-level Catch-All Route
 * 
 * Handles paths like /services, /about, /contact for host-based tenant resolution.
 * When the tenant is resolved from the host (e.g., primarypublic.ahliweb.com),
 * pages are served at root paths without requiring /primary/ prefix.
 */

// SSR Mode
export const prerender = false;

const { slug } = Astro.params;
const rawSlug = slug || '';
const currentSlug = rawSlug === '' ? 'home' : rawSlug; // Normalize root to 'home'

// Get Tenant Context from middleware
const { tenant_id, tenant_slug, runtime } = Astro.locals;
const env = runtime?.env || {};

// If no tenant context, something is wrong with middleware
if (!tenant_id || !tenant_slug) {
    console.error('[Page] No tenant context available');
    return new Response('Tenant Not Found', { status: 404 });
}

// Initialize Scoped Client
const supabase = createScopedClient({
    'x-tenant-id': tenant_id
}, env);

// 3. Determine Flow
let currentTemplateSlug = null;
let templateId = null;
let pageContent = null;
let meta = { title: 'Page', description: '' };
let is404 = false;
let mergedContent = [];

// Error State
let errorState = null;

if (!supabase) {
    console.error('[Page] Critical: Supabase Client Failed to Initialize. Missing Env Vars?');
    errorState = "Service Configuration Error";
    Astro.response.status = 500;
} else {
    try {
        // 1. Fetch Page
        const { data: pageData, error: pageError } = await supabase
            .from('pages')
            .select('*')
            .eq('slug', currentSlug)
            .eq('status', 'published')
            .maybeSingle();

        if (pageError) throw pageError;

        // 2. Fetch Template Assignments
        const { data: assignments, error: assignmentError } = await supabase
            .from('template_assignments')
            .select('route_type, template_id')
            .eq('channel', 'web')
            .in('route_type', ['home', '404', 'archive', 'search', 'single', 'post']); // Added 'post'
            
        if (assignmentError) console.warn('[Page] Template Assignment Fetch Warning:', assignmentError);

        const assignmentMap = {};
        (assignments || []).forEach(a => assignmentMap[a.route_type] = a.template_id);


        if (pageData) {
            // Page Found
            meta.title = pageData.meta_title || pageData.title;
            meta.description = pageData.meta_description;
            pageContent = pageData.puck_layout_jsonb || { content: [], root: {} };

            // Determine Template
            if (pageData.template && pageData.template !== 'default') {
                templateId = pageData.template;
            } else {
                // Fallback to assigned templates
                if (currentSlug === 'home') {
                    templateId = assignmentMap['home'];
                } else {
                    templateId = assignmentMap['single'];
                }
            }
        } else {
            // Page Not Found - Check for Special Routes (Articles)
            
            // Case: Article Detail (/articles/:slug)
            const isArticlePath = currentSlug.startsWith('articles/') && currentSlug.split('/').length === 2;
            
            if (isArticlePath) {
                const articleSlug = currentSlug.split('/')[1];
                const { data: articleData, error: articleError } = await supabase
                    .from('articles')
                    .select('*')
                    .eq('slug', articleSlug)
                    .eq('status', 'published')
                    .maybeSingle();

                if (articleData) {
                    meta.title = articleData.title;
                    // Simple article content structure
                    // In real app, we might use a dedicated 'post' template or injection
                    pageContent = { 
                        content: [
                             {
                                type: "ArticleDetail", // Hypothetical component or we construct standard blocks
                                props: { article: articleData }
                             }
                        ],
                        root: { title: articleData.title } 
                    };
                    
                    // Use 'post' template if available, else 'single'
                    templateId = assignmentMap['post'] || assignmentMap['single'];
                    
                    // Fallback content injection if no Puck content
                    if (!pageContent.content[0].type && articleData.content) {
                         // If we are strictly using PuckRenderer, we need compatible data.
                         // For now, let's assume we render it via a simple block or just standard text.
                         // But wait, the existing code pushes `pageContent.content`.
                         // If I just want to show HTML content, I might need a specific block.
                         // Let's create a generic "HTML" block representation for now.
                         pageContent = {
                             content: [{
                                 type: "RichText",
                                 props: { content: articleData.content }
                             }],
                             root: { title: articleData.title }
                         };
                    }
                } else {
                    is404 = true;
                }
            } 
            // Case: Articles List (/articles)
            else if (currentSlug === 'articles') {
                 // No CMS Page named 'articles' found (checked above), so we render default list
                 // Fetch recent articles
                 const { data: recentArticles } = await supabase
                    .from('articles')
                    .select('title, slug, excerpt, published_at')
                    .eq('status', 'published')
                    .order('published_at', { ascending: false })
                    .limit(10);
                 
                 meta.title = "Articles";
                 pageContent = {
                     content: [{
                         type: "ArticleList", // Needs to correspond to a Puck component OR we handle it
                         props: { articles: recentArticles || [] }
                     }],
                     root: { title: "Articles" }
                 };
                 templateId = assignmentMap['archive'] || assignmentMap['single'];
            }
            else if (currentSlug === 'home') {
                templateId = assignmentMap['home'];
                meta.title = 'Home';
            } else {
                is404 = true;
                templateId = assignmentMap['404'];
                meta.title = 'Page Not Found';
                Astro.response.status = 404;
            }
        }

        // 4. Fetch Template & Parts
        if (templateId) {
            // ... (Template fetching logic remains similar, will be kept by replace but I need to ensure I don't break it)
            // Wait, I am replacing a large block to insert logic.
            // I should copy the template fetching part or ensure my replacement chunk connects correctly.
            // The template fetching block is lines 109-155.
            // I should include it in my replacement or stop before it if I can.
            // My edit targets lines 54-164 (the try block).
            // That's risky. I will paste the helper logic back.
             const { data: template, error: templateError } = await supabase
                .from('templates')
                .select('*')
                .eq('id', templateId)
                .maybeSingle();
            
            if (templateError) console.warn('[Page] Template Fetch Warning:', templateError);

            if (template) {
                currentTemplateSlug = template.slug;
                const parts = template.parts || {};
                const partIds = Object.values(parts).filter(Boolean);
                
                let partDataMap = {};
                if (partIds.length > 0) {
                    const { data: partsData } = await supabase
                        .from('template_parts')
                        .select('*')
                        .in('id', partIds);
                        
                    (partsData || []).forEach(p => partDataMap[p.id] = p);
                }

                if (parts.header && partDataMap[parts.header]) {
                     const headerContent = partDataMap[parts.header].data?.content || [];
                     mergedContent.push(...headerContent);
                }

                const pageHasContent = pageContent && pageContent.content && pageContent.content.length > 0;
                
                if (pageHasContent) {
                     mergedContent.push(...pageContent.content);
                } else {
                     const templateContent = template.data?.content || [];
                     mergedContent.push(...templateContent);
                }

                if (parts.footer && partDataMap[parts.footer]) {
                     const footerContent = partDataMap[parts.footer].data?.content || [];
                     mergedContent.push(...footerContent);
                }
                
            } else {
                if (pageContent) mergedContent = pageContent.content || [];
            }
        } else {
            if (pageContent) mergedContent = pageContent.content || [];
        }

    } catch (err: any) {
        console.error('[Page] Render Error:', err);
        errorState = err.message || "Unknown Render Error";
        Astro.response.status = 500;
    }

}

const finalPuckData = {
    content: mergedContent,
    root: { title: meta.title }
};

const LayoutComponent = (currentTemplateSlug === 'awtemplate01') ? AWT01Layout : Layout;

// For host-based resolution, use root paths (no tenant prefix)
const layoutProps = {
    title: meta.title,
    description: meta.description,
    tenantSlug: '' // Empty string = no prefix in URLs
};
---

<LayoutComponent {...layoutProps}>
  <main>
    {errorState ? (
        <div class="container mx-auto py-20 text-center text-red-600">
            <h1 class="text-4xl font-bold mb-4">500 - Server Error</h1>
            <p className="font-mono bg-gray-100 p-4 rounded inline-block text-left text-sm text-gray-800">
                {errorState}
            </p>
        </div>
    ) : (
        <>
            {finalPuckData.content.length > 0 ? (
            <PuckRenderer data={finalPuckData} />
            ) : (
            <div class="container mx-auto py-20 text-center">
                {is404 ? (
                    <div>
                        <h1 class="text-4xl font-bold mb-4">404 - Not Found</h1>
                        <p>The page you are looking for does not exist.</p>
                    </div>
                ) : (
                    <p>No content found.</p>
                )}
            </div>
            )}
        </>
    )}
  </main>
</LayoutComponent>
